// plugins/ics-generator/index.ts
import { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';
import { DynamoDBClient, GetItemCommand, UpdateItemCommand } from '@aws-sdk/client-dynamodb';
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import { Handler } from 'aws-lambda';
import { Readable } from 'stream';
import { createEvent, type DateTime } from 'ics';

const ddb = new DynamoDBClient({});
const evb = new EventBridgeClient({});
const s3 = new S3Client({});

const TABLE_NAME = process.env.TABLE_NAME!;
const EVENT_BUS_NAME = process.env.EVENT_BUS_NAME!;
const BUCKET_NAME = process.env.BUCKET_NAME!;

function streamToString(stream: Readable): Promise<string> {
  const chunks: Uint8Array[] = [];
  return new Promise((resolve, reject) => {
    stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf-8')));
  });
}

export const handler: Handler = async (event) => {
  const detail = event.detail;
  const emailId = detail.emailId as string;

  const meta = await ddb.send(new GetItemCommand({
    TableName: TABLE_NAME,
    Key: { emailId: { S: emailId } },
  }));

  const s3Key = `emails/${emailId}.txt`;
  const rawEmail = await s3.send(new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: s3Key,
  }));
  const rawText = await streamToString(rawEmail.Body as Readable);

  // Placeholder: extract start date and title (consider using Amazon Comprehend or Bedrock in future)
  const title = 'Auto-generated Event';
  const description = rawText.substring(0, 100);
  const now = new Date();
  const start = [now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours(), now.getUTCMinutes()] as DateTime;
  const end = [now.getUTCFullYear(), now.getUTCMonth() + 1, now.getUTCDate(), now.getUTCHours() + 1, now.getUTCMinutes()] as DateTime;

  const { error, value: icsContent } = createEvent({
    start,
    end,
    title,
    description,
    location: 'Generated by Octomate',
    status: 'CONFIRMED',
  });

  if (error) {
    console.error('ICS generation error:', error);
    throw error;
  }

  await ddb.send(new UpdateItemCommand({
    TableName: TABLE_NAME,
    Key: { emailId: { S: emailId } },
    UpdateExpression: 'SET pluginStatus.icsGenerator = :ics',
    ExpressionAttributeValues: {
      ':ics': { S: JSON.stringify({ status: 'done', ics: icsContent, completedAt: new Date().toISOString() }) },
    },
  }));

  await evb.send(new PutEventsCommand({
    Entries: [{
      EventBusName: EVENT_BUS_NAME,
      Source: 'octomate.plugin.ics-generator',
      DetailType: 'plugin/ics-generator/finsih',
      Detail: JSON.stringify({ 
        emailId, 
        pluginName: 'ics-generator', 
        success: true, 
        summary: (icsContent ?? '').slice(0, 80) 
      }),
    }],
  }));
};
